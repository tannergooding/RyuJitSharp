// Copyright Â© Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information.
//
// Based on the RyuJIT compiler from dotnet/runtime.
// Original source is Copyright (c) .NET Foundation and Contributors. Licensed under the MIT License (MIT).

using System;
using System.Runtime.CompilerServices;

namespace RyuJitSharp;

// #EEToJitInterface
// ICorJitCompiler is the interface that the EE uses to get IL bytecode converted to native code. Note that
// to accomplish this the JIT has to call back to the EE to get symbolic information.  The code:ICorJitInfo
// type passed as 'comp' to compileMethod is the mechanism to get this information.  This is often the more
// interesting interface.
public unsafe partial struct ICorJitCompiler : ICorJitCompiler.Interface
{
    internal Vtbl* lpVtbl;

    public CorJitResult compileMethod(ICorJitInfo* comp, CORINFO_METHOD_INFO* info, uint flags, byte** nativeEntry, uint* nativeSizeOfCode) => lpVtbl->compileMethod((ICorJitCompiler*)Unsafe.AsPointer(ref this), comp, info, flags, nativeEntry, nativeSizeOfCode);

    public void ProcessShutdownWork(ICorStaticInfo* info) => lpVtbl->ProcessShutdownWork((ICorJitCompiler*)Unsafe.AsPointer(ref this), info);

    public void getVersionIdentifier(Guid* versionIdentifier) => lpVtbl->getVersionIdentifier((ICorJitCompiler*)Unsafe.AsPointer(ref this), versionIdentifier);

    public void setTargetOS(CORINFO_OS os) => lpVtbl->setTargetOS((ICorJitCompiler*)Unsafe.AsPointer(ref this), os);

    public interface Interface
    {
        // compileMethod is the main routine to ask the JIT Compiler to create native code for a method. The
        // method to be compiled is passed in the 'info' parameter, and the code:ICorJitInfo is used to allow the
        // JIT to resolve tokens, and make any other callbacks needed to create the code. nativeEntry, and
        // nativeSizeOfCode are just for convenience because the JIT asks the EE for the memory to emit code into
        // (see code:ICorJitInfo.allocMem), so really the EE already knows where the method starts and how big
        // it is (in fact, it could be in more than one chunk).
        //
        // * In the 32 bit jit this is implemented by code:CILJit.compileMethod
        // * For the 64 bit jit this is implemented by code:PreJit.compileMethod
        // Note: setTargetOS must be called before this api is used.
        CorJitResult compileMethod(ICorJitInfo* comp, CORINFO_METHOD_INFO* info, uint flags, byte** nativeEntry, uint* nativeSizeOfCode);

        // Do any appropriate work at process shutdown.  Default impl is to do nothing.
        void ProcessShutdownWork(ICorStaticInfo* info) { }

        // The EE asks the JIT for a "version identifier". This represents the version of the JIT/EE interface.
        // If the JIT doesn't implement the same JIT/EE interface expected by the EE (because the JIT doesn't
        // return the version identifier that the EE expects), then the EE fails to load the JIT.
        void getVersionIdentifier(Guid* versionIdentifier);

        // Some JIT's may support multiple OSs. This api provides a means to specify to the JIT what OS it should
        // be trying to compile. This api does not produce any errors, any errors are to be generated by the
        // the compileMethod call, which will call back into the VM to ensure bits are correctly setup.
        //
        // Note: this api MUST be called before the compileMethod is called for the first time in the process.
        void setTargetOS(CORINFO_OS os);
    }

    public struct Vtbl
    {
        public delegate* unmanaged[MemberFunction]<ICorJitCompiler*, ICorJitInfo*, CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult> compileMethod;

        public delegate* unmanaged[MemberFunction]<ICorJitCompiler*, ICorStaticInfo*, void> ProcessShutdownWork;

        public delegate* unmanaged[MemberFunction]<ICorJitCompiler*, Guid*, void> getVersionIdentifier;

        public delegate* unmanaged[MemberFunction]<ICorJitCompiler*, CORINFO_OS, void> setTargetOS;
    }
}
